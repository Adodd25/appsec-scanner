# Common Vulnerability Patterns and Remediation

This document provides detailed patterns for identifying and fixing common security vulnerabilities in Python, JavaScript, and Node.js applications.

## Cross-Site Scripting (XSS)

### Reflected XSS

**Vulnerable Pattern:**
```python
# Python/Flask
@app.route('/search')
def search():
    query = request.args.get('q', '')
    return f"<h1>Results for: {query}</h1>"  # Direct insertion!
```

```javascript
// JavaScript
document.getElementById('results').innerHTML = userInput;  // Direct insertion!
```

**Secure Pattern:**
```python
# Python/Flask - Use template auto-escaping
@app.route('/search')
def search():
    query = request.args.get('q', '')
    return render_template('search.html', query=query)  # Auto-escaped

# Or manually escape
from markupsafe import escape
return f"<h1>Results for: {escape(query)}</h1>"
```

```javascript
// JavaScript - Use textContent or proper escaping
document.getElementById('results').textContent = userInput;

// Or use a framework with auto-escaping (React, Vue, etc.)
```

### Stored XSS

**Vulnerable Pattern:**
```javascript
// Storing unvalidated user input
app.post('/comment', (req, res) => {
  db.insert({ comment: req.body.comment });  // No sanitization!
});
```

**Secure Pattern:**
```javascript
// Validate and sanitize before storage
const validator = require('validator');
const createDOMPurify = require('dompurify');
const { JSDOM } = require('jsdom');

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

app.post('/comment', (req, res) => {
  const sanitized = DOMPurify.sanitize(req.body.comment);
  db.insert({ comment: sanitized });
});
```

## SQL Injection

### Basic SQL Injection

**Vulnerable Pattern:**
```python
# Python
cursor.execute(f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'")
```

```javascript
// Node.js
const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;
connection.query(query, callback);
```

**Secure Pattern:**
```python
# Python - Parameterized queries
cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s", (username, password))

# Python with SQLAlchemy ORM
user = User.query.filter_by(username=username).first()
```

```javascript
// Node.js - Parameterized queries
connection.query('SELECT * FROM users WHERE username = ? AND password = ?', [username, password], callback);

// Or use an ORM like Sequelize
User.findOne({ where: { username: username } });
```

### NoSQL Injection

**Vulnerable Pattern:**
```javascript
// MongoDB - Vulnerable
db.collection('users').findOne({ 
  username: req.body.username,
  password: req.body.password  // Can be manipulated with {$ne: null}
});
```

**Secure Pattern:**
```javascript
// MongoDB - Secure
const validator = require('validator');

if (typeof req.body.username !== 'string' || typeof req.body.password !== 'string') {
  return res.status(400).send('Invalid input');
}

db.collection('users').findOne({ 
  username: req.body.username,
  password: req.body.password
});
```

## Command Injection

**Vulnerable Pattern:**
```python
# Python
import os
os.system(f"ping -c 1 {user_input}")  # Can inject: 8.8.8.8; rm -rf /
```

```javascript
// Node.js
const { exec } = require('child_process');
exec(`ping -c 1 ${userInput}`, callback);  // Dangerous!
```

**Secure Pattern:**
```python
# Python - Use subprocess with argument list
import subprocess
subprocess.run(["ping", "-c", "1", user_input], check=True, timeout=5)

# Additional validation
import re
if not re.match(r'^[\w\.-]+$', user_input):
    raise ValueError("Invalid input")
```

```javascript
// Node.js - Use execFile with argument array
const { execFile } = require('child_process');
execFile('ping', ['-c', '1', userInput], { timeout: 5000 }, callback);

// Or better yet, use native libraries
const ping = require('ping');
ping.promise.probe(userInput);
```

## Path Traversal

**Vulnerable Pattern:**
```python
# Python
@app.route('/download/<filename>')
def download(filename):
    return send_file(f"/uploads/{filename}")  # Can access: ../../etc/passwd
```

```javascript
// Node.js
app.get('/file/:name', (req, res) => {
  res.sendFile(`./uploads/${req.params.name}`);  // Vulnerable!
});
```

**Secure Pattern:**
```python
# Python
import os
from werkzeug.utils import secure_filename

@app.route('/download/<filename>')
def download(filename):
    safe_filename = secure_filename(filename)
    filepath = os.path.join('/uploads', safe_filename)
    
    # Verify path is still within uploads directory
    if not os.path.abspath(filepath).startswith(os.path.abspath('/uploads')):
        abort(400)
    
    return send_file(filepath)
```

```javascript
// Node.js
const path = require('path');

app.get('/file/:name', (req, res) => {
  const uploadsDir = path.resolve('./uploads');
  const requestedFile = path.resolve(uploadsDir, req.params.name);
  
  // Verify path is still within uploads directory
  if (!requestedFile.startsWith(uploadsDir)) {
    return res.status(400).send('Invalid file path');
  }
  
  res.sendFile(requestedFile);
});
```

## Insecure Deserialization

**Vulnerable Pattern:**
```python
# Python - pickle is dangerous with untrusted data
import pickle
user_data = pickle.loads(request.data)  # Can execute arbitrary code!
```

```javascript
// Node.js - eval is dangerous
const config = eval(userInput);  // Never do this!
```

**Secure Pattern:**
```python
# Python - Use JSON for untrusted data
import json
user_data = json.loads(request.data)

# If you need more complex objects, validate thoroughly
from pydantic import BaseModel, ValidationError

class UserData(BaseModel):
    name: str
    age: int

try:
    user_data = UserData(**json.loads(request.data))
except ValidationError:
    abort(400)
```

```javascript
// Node.js - Use JSON.parse
const config = JSON.parse(userInput);

// Validate with schema
const Ajv = require('ajv');
const ajv = new Ajv();

const schema = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    age: { type: 'number' }
  },
  required: ['name', 'age']
};

const validate = ajv.compile(schema);
if (!validate(config)) {
  throw new Error('Invalid data');
}
```

## Cross-Site Request Forgery (CSRF)

**Vulnerable Pattern:**
```python
# Python/Flask - No CSRF protection
@app.route('/transfer', methods=['POST'])
def transfer():
    amount = request.form['amount']
    to_account = request.form['to']
    # Process transfer without CSRF token
```

```javascript
// Express - No CSRF protection
app.post('/transfer', (req, res) => {
  const { amount, to } = req.body;
  // Process transfer
});
```

**Secure Pattern:**
```python
# Python/Flask - With CSRF protection
from flask_wtf.csrf import CSRFProtect

csrf = CSRFProtect(app)

@app.route('/transfer', methods=['POST'])
@csrf.exempt  # Only if you're using token-based auth
def transfer():
    # CSRF token automatically validated
    amount = request.form['amount']
    to_account = request.form['to']
```

```javascript
// Express - With CSRF protection
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.post('/transfer', csrfProtection, (req, res) => {
  const { amount, to } = req.body;
  // CSRF token automatically validated
});
```

## Insecure Random Values

**Vulnerable Pattern:**
```python
# Python - Predictable random
import random
session_id = str(random.randint(1000, 9999))  # Not cryptographically secure!
```

```javascript
// JavaScript - Predictable random
const token = Math.random().toString(36).substr(2);  // Not secure!
```

**Secure Pattern:**
```python
# Python - Cryptographically secure random
import secrets
session_id = secrets.token_urlsafe(32)
```

```javascript
// Node.js - Cryptographically secure random
const crypto = require('crypto');
const token = crypto.randomBytes(32).toString('hex');
```

## Hardcoded Secrets

**Vulnerable Pattern:**
```python
# Python - Hardcoded credentials
API_KEY = "sk-1234567890abcdef"
DATABASE_URL = "postgresql://user:password@localhost/db"
```

```javascript
// JavaScript - Hardcoded secrets
const apiKey = 'sk-1234567890abcdef';
const dbPassword = 'mypassword123';
```

**Secure Pattern:**
```python
# Python - Environment variables
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv('API_KEY')
DATABASE_URL = os.getenv('DATABASE_URL')

if not API_KEY:
    raise ValueError("API_KEY not set")
```

```javascript
// Node.js - Environment variables
require('dotenv').config();

const apiKey = process.env.API_KEY;
const dbPassword = process.env.DB_PASSWORD;

if (!apiKey) {
  throw new Error('API_KEY not set');
}
```

## Weak Cryptography

**Vulnerable Pattern:**
```python
# Python - Weak algorithms
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()  # MD5 broken
password_hash = hashlib.sha1(password.encode()).hexdigest()  # SHA1 deprecated
```

```javascript
// Node.js - Weak algorithms
const crypto = require('crypto');
const hash = crypto.createHash('md5').update(password).digest('hex');
```

**Secure Pattern:**
```python
# Python - Strong password hashing
from argon2 import PasswordHasher

ph = PasswordHasher()
password_hash = ph.hash(password)

# Verify
try:
    ph.verify(password_hash, password)
except:
    print("Invalid password")

# Or use bcrypt
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
```

```javascript
// Node.js - Strong password hashing
const bcrypt = require('bcrypt');

const saltRounds = 12;
const hash = await bcrypt.hash(password, saltRounds);

// Verify
const match = await bcrypt.compare(password, hash);
```

## XML External Entity (XXE) Injection

**Vulnerable Pattern:**
```python
# Python - Vulnerable XML parsing
from xml.etree import ElementTree as ET
tree = ET.parse(user_uploaded_file)  # Can process external entities!
```

```javascript
// Node.js - Vulnerable XML parsing
const xml2js = require('xml2js');
xml2js.parseString(userXML, callback);  // Default settings vulnerable
```

**Secure Pattern:**
```python
# Python - Secure XML parsing
from defusedxml.ElementTree import parse
tree = parse(user_uploaded_file)  # Prevents XXE attacks
```

```javascript
// Node.js - Secure XML parsing
const xml2js = require('xml2js');
const parser = new xml2js.Parser({
  explicitRoot: false,
  explicitArray: false,
  xmlns: false,
  // Disable external entities
  resolveEntities: false
});
parser.parseString(userXML, callback);
```

## Security Headers

**Recommended Security Headers:**
```python
# Python/Flask
from flask import Flask
from flask_talisman import Talisman

app = Flask(__name__)
Talisman(app, 
    force_https=True,
    strict_transport_security=True,
    content_security_policy={
        'default-src': "'self'",
        'script-src': "'self'",
        'style-src': "'self'"
    }
)
```

```javascript
// Node.js/Express
const helmet = require('helmet');

app.use(helmet());
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'"],
    styleSrc: ["'self'"]
  }
}));
```

## Input Validation Best Practices

1. **Whitelist over Blacklist**: Define what is allowed rather than what is forbidden
2. **Validate Type**: Ensure input matches expected data type
3. **Validate Length**: Check min/max length constraints
4. **Validate Range**: For numbers, ensure within acceptable range
5. **Validate Format**: Use regex for specific formats (email, phone, etc.)
6. **Sanitize**: Remove or encode potentially dangerous characters
7. **Validate on Server**: Never trust client-side validation alone

## Quick Remediation Checklist

- [ ] Use parameterized queries for all database operations
- [ ] Validate and sanitize all user inputs
- [ ] Use strong, modern cryptographic functions
- [ ] Store secrets in environment variables, not code
- [ ] Implement proper authentication and authorization
- [ ] Use security headers (CSP, HSTS, X-Frame-Options, etc.)
- [ ] Enable HTTPS everywhere
- [ ] Implement rate limiting on sensitive endpoints
- [ ] Log security events
- [ ] Keep dependencies updated
- [ ] Use security linters in CI/CD pipeline
- [ ] Implement proper error handling (no stack traces to users)
- [ ] Use secure session management
- [ ] Implement CSRF protection
- [ ] Validate file uploads (type, size, content)
